# 컴퓨터 공학 기초 실험 2 보고서

## 실험제목: Shifter & Counter

## 실험일자: 20 21 년 10 월 18 일 (월)

## 제출일자: 20 21 년 10 월 30 일 (토)

## 학 과: 컴퓨터정보공학부

## 담당교수: 공진흥 교수님

## 실습분반: 월요일 0, 1, 2

## 학 번: 2018202046

## 성 명: 이준휘


1. 제목 및 목적

```
A. 제목
Shifter & Counter
B. 목적
해당 수업을 통해 Shifter에서의 동작(LSL, LSR, ASR)에 대해 이해할 수 있다. Counter의 동
작 방식을 이해하고 loadable counter와 ring counter의 차이를 이해한다. FSM을 통해
Combinational Circuit과 Sequential Circuit으로 나누어 설계할 수 있다.
```
2. 원리(배경지식)
    i. Moore FSM
       Moore FSM은 쉽게 말해 output이 현재 state에만 의존하는 것을 의미한다.
       Moore FSM은 clk edge에 의해서만 output이 바뀌기 때문에 도중에 값이 바뀔
       수 있는 Mealy FSM보다 안전하다. 또한 설계 단계에서 동작을 단순화하여 설명
       함으로서 더욱 쉽게 설계를 할 수 있다는 장점이 있다.

```
ii. Mealy FSM
Mealy FSM은 output이 현재 state와 output 둘 다 의존한다. 해당 방식을 사용
할 경우 결과가 sequential circuit을 거치지 않기 때문에 더욱 빠른 동작이 가능
하다. 또한 상태가 Moore보다 더 적게 설계가 가능하다.
```
```
iii. ring counter
ring counter란 Flip-Flop이 이어진 형태로 설계된 shift register를 의미한다. 레지
스터의 값이 각각에 상황에 맞게 옆으로 전달되면서 값이 one-hot 방식으로 값
을 표현한다. 해당 방식을 사용할 경우 각 값, 즉 state의 개수만큼 register가 필
요하기 때문에 카운트하는 수가 많아질수록 register의 양으로 인한 회로의 단가
가 올라가게 된다. 또한 초기값이 항상 0 으로 고정되어 있다는 단점이 있다.
```
```
iv. loadable counter
해당 회로는 중간에 값을 변경할 수 있는 counter를 의미한다. 해당 회로는 굳
이 one-hot 방식으로 설계하지 않아도 설계가 가능하다. 또한 초기 값을 직접
설정할 수 있다는 장점이 있다.
```
```
v. shifter
```

### 해당 회로는 주어진 비트를 좌 또는 우로 일정한 비트만큼 옮기는 역할을 한다.

### 좌로 옮길 때는 LSL로 부르며 좌측에 0 를 추가하는 방식으로 가동한다. 우로 옮

### 기는 방법은 LSR 또는 ASR이 있다. LSR은 우측으로 0 을 삽입하는 방식으로 가

### 동하고, ASR은 우측에 MSB의 비트를 삽입하는 방식으로 가동한다.

3. 설계 세부사항
    i. mx 4
       해당 모듈은 4 - to-1 MUX를 구현하였다. 해당 모듈에서 이전에 설계한 MX2를
       활용하여 2 자리 입력을 받아 4 가지 경우를 구분할 수 있도록 했다.

```
ii. LSL 8
해당 모듈은 LSL 8 bits를 구현하였다. 해당 모듈에서는 mx4를 통해 각 자리에
shamt만큼 좌측으로 옮겨진 값을 연결하여 구현하도록 했다. 빈 자리는 0 을 넣
는다.
```
```
iii. LSR 8
해당 모듈은 LSR 8 bits를 구현하였다. 해당 모듈에서는 mx4를 통해 각 자리에
shamt만큼 우측으로 옮겨진 값을 연결하여 구현하도록 했다. 빈 자리는 0 을 넣
는다.
```
```
iv. ASR 8
해당 모듈은 ASR 8 bits를 구현하였다. 해당 모듈에서는 mx4를 통해 각 자리에서
shamt만큼 우측으로 옮겨진 값을 연결하여 구현하도록 했다. 빈 자리에는 MSB
를 넣는다.
```
```
v. _register8_r
해당 모듈은 8bit register를 구현하였다. 해당 모듈에서는 _dff_r를 8 개 연결하여
각 자리의 데이터를 저장할 수 있도록 하였다.
```
```
vi. cc_logic
해당 모듈에서는 shifter 8 의 combinational circuit 부분을 한 번에 구현한 회로다.
해당 회로에서는 각 상태를 parameter로 이름을 지어준 뒤 always문과 case문을
활용해 다음 상태를 넘겨주는 역할을 만들었고, LSL8, LSR8, ASR8 모듈을 이용하
여 해당 값을 출력하는 역할을 수행하였다.
```

```
vii. shifter
해당 모듈은 shifter를 실질적으로 구현한 회로다. 해당 모듈에서는 cc_logic을 통
해 Combinational 부분을, _register8_r을 통해 sequential을 구현하고 이를 연결
함으로써 FSM을 완성했다.
```
viii. Drawing the finite state diagram

```
ix. op
IDLE = 000
LOAD = 001
INC = 010
INC2 = 011
DEC = 100
DEC2 = 101
```

```
IDLE : d_out = 0000_
LOAD : d_out = d_in
INC : d_out = d_out+
INC 2 : d_out = d_out+
DEC : d_out = d_out- 1
DEC2 : d_out = d_out- 1
```
```
x. cla 8
해당 모듈은 8 bit CLA Adder가 기존에 만든 cla4 2개를 이어 붙어서 구성하였다.
```
```
xi. ns_logic
해당 모듈은 case문을 이용하여 지정된 현재 parameter와 load, inc에 따라 다음
상태을 바꿔줌으로써 회로를 구성한다.
```
```
xii. os_logic
해당 모듈은 case문을 이용하여 현재 parameter에 따라 1 을 더하는 cla, 1을 빼
는 cla, 현재 값 3 개 중 하나로 출력을 결정함으로써 회로를 구성하였다.
```
4. 설계 검증 및 실험 결과

A. 시뮬레이션 결과

```
해당 testbench는 mx4를 검증한다.
```

해당 testbench는 LSL8을 검증한다. shamt에 따라 값이 왼쪽으로 이동하는 것을 볼 수
있다.

해당 testbench는 LSR8을 검증한다. shamt에 따라 값이 오른쪽으로 이동하고 0 이 채워진
다.


해당 testbench에서는 ASR8을 검증한다. shamt에 따라 값이 우측으로 이동하는 모습이
다. 이 때 MSB의 값이 채워진다.

해당 testbench에서는 _register8_r를 검증한다. 정상적으로 모든 비트에 값이 들어가는
것을 볼 수 있다.


해당 testbench에서는 cc_logic을 검증하였다. 각 op마다 해당하는 shifter가 정상적으로
동작하는 것을 알 수 있다.

해당 testbench에서는 shifter8을 검증하였다. 현재 값을 활용하여 지속적으로 shift를 할
수 있음을 볼 수 있다.


해당 모듈에서는 cla 8 을 검증한다. cla4 2개가 각각 잘 연결되어 있는 것을 확인할 수 있
다.

해당 모듈에서는 ns_logic을 검증한다. 각 파라미터에서 load와 inc에 따라 값이 바뀌는
것을 알 수 있다.


해당 모듈에서는 os_logic을 검증한다. os_logic에서는 현재 파라미터에 따라 cla나 현재
상태를 바꿔가면서 출력하는 과정이 정상적으로 나온다.

해당 모듈에서는 cntr8을 점증한다. 해당 회로에서 각 op의 값마다 정상적으로 값이 도
출되는 것을 확인할 수 있다.

B. 합성(synthesis) 결과

```
shifter
```


- counter


### 해당 모듈의 설계를 확인하면 각각의 모듈이 정상적으로 설계되어 연결되었음을 알 수

### 있다.

C. FPGA board targeting 결과

5. 고찰 및 결론

```
A. 고찰
이번 주차의 과제를 진행하면서 counter를 검증하는 과정에서 pin 개수가 모자라는 문제
가 발생하였다. 해당 문제는 조교님에게 메일로 장치를 바꾸라는 조언을 통해 이를 해결
할 수 있었다. 또한 각각의 모듈이 양이 많아 시간적으로 촉박함이 있었다.
```
```
B. 결론
loadable counter의 경우 초기값을 설정할 수 있다는 장점으로 인해 지정된 시간부터 시
간을 측정하는 등에 이용할 수 있다. ring counter의 경우 초기값은 0 부터 시작하지만
register만을 사용하여 간편하게 구성할 수 있으므로 고정된 시간을 측정하는 등에 활용
하기 좋을 것이다. barrel shifter는 한번의 연산을 통해 다수의 비트를 이동시킬 수 있는
하드웨어 장치를 의미한다. n비트의 register에서 n개의 비트를 이동해야할 경우 n-to- 1
MUX가 n개 필요한 것을 알 수 있다.
```
6. 참고문헌
    이준환 교수님/디지털논리회로 1 /광운대학교(컴퓨터정보공학부)/
    이준환 교수님/디지털논리회로2/광운대학교(컴퓨터정보공학부)/
    barrel shifter/여러가지 case문과 barrel shifter : 네이버 블로그 (naver.com)


# 컴퓨터 공학 기초 실험 2 보고서

## 실험제목: Register File

## 실험일자: 20 21 년 10 월 18 일 (월)

## 제출일자: 20 21 년 10 월 31 일 (일)

## 학 과: 컴퓨터정보공학부

## 담당교수: 공진흥 교수님

## 실습분반: 월요일 0, 1, 2

## 학 번: 2018202046

## 성 명: 이준휘

1. 제목 및 목적


```
A. 제목
Register File
B. 목적
해당 수업을 통해 Register File이 어떻게 구성되어 있는지 알 수 있다. Register File에서
Write과 Read의 메커니즘을 이해하고 이를 구현할 수 있다. Stack과 Queue의 차이를 이
해할 수 있다.
```
2. 원리(배경지식)
    i. Stack
       Stack이란 선입후출, 즉 LIFO(Last in First out)을 만족하는 데이터 구조를 의미한
       다. 삽입을 할 시 데이터를 stack의 최상위(TOP)에 저장한다. 그리고 데이터를
       꺼낼 때는 TOP 위치에 있는 데이터를 호출하여 꺼낸다. 이를 통해 위와 같은 데
       이터 출력을 만족시킬 수 있다.

```
해당 자료 구조는 우리가 쉽게 찾아볼 수 있다. 코딩을 할 때 함수는 Stack의 방
식으로 호출된다. 그리고 반환할 때에는 가장 나중에 호출한 함수 먼저 반환을
하는 구조를 만족시킨다.
```
```
우리가 크롬을 들어갔을 때 이전에 방문한 웹 페이지 또한 이러한 구조를 만족
한다. 가장 최근에 접속한 웹 페이지를 우선적으로 반복하는 것이 stack 구조이
기 때문이다.
```
```
ii. Queue
Queue란 선입선출, 즉 FIFO(First in First out)을 만족하는 데이터 구조를 의미한
다. 삽입을 할 시 Queue의 가장 끝(rear)에 데이터가 저장된다. 그리고 데이터를
읽을 때에는 가장 처음(Front)에 있는 데이터를 POP함으로써 선입선출 구조를
만족시킨다.
```
```
해당 구조를 만들 수 있는 방법으로는 일반적으로 배열(Array)을 사용하거나 원
형 Linked List를 구현하는 방법이 있다. 배열의 경우에는 가장 앞쪽에 데이터를
읽고 가장 뒤쪽에 있는 데이터를 넣음으로써 이를 만족시킬 수 있다. 하지만 해
당 방식은 데이터를 POP 할수록 앞쪽의 빈공간이 많아지기 때문에 메모리 사용
측면에서 비효율적이다.
```

### 해당 방식을 개선하기 위해 원형으로 데이터를 연결하여 계속 순환하도록 함으

### 로써 이를 해결한다.

```
iii. Register File
RF는 데이터가 저장되는 Register들과 읽기를 수행하는 Read Operation, 쓰기를
수행하는 Write Operation 부분으로 구성되어있다.
```
```
Write Operation에서는 wAddr를 통해 쓸 위치의 주소와 저장할 데이터, 그리고
쓰기 활성화 신호인 EN을 입력받는다. Decoder를 통해 해당 위치에 접근하여
데이터를 EN이 활성화 되어있을 경우 쓰는 방식으로 이를 구현한다.
```
```
Read Operation에서는 rAddr를 통해 읽을 위치의 주소를 가져온다. 그리고
MUX를 통해 읽을 데이터 위치에서 데이터를 꺼내어서 이를 수행한다.
```
3. 설계 세부사항
    i. register32_r_en
       해당 파일에서는 3 2bits의 reset_n과 enable신호를 받는 레지스터를 구현한다.
       Always 문을 활용하여 CLK이 falling edge를 갖거나 reset_n이 rising edge를 가
       질 때 동작하도록 구현한다. 그리고 if문을 활용하여 en의 신호가 없을 시 기존
       의 데이터를 유지하도록 하고, en 신호가 있을 시 쓰기 작업을 수행할 수 있도
       록 한다. 레지스터는 기존에 만든 _dff_r_en 모듈을 이용한다.

```
ii. register32_
해당 모듈에서는 32bit의 register들을 8 개를 만든다. 해당 모듈은 위에
resgister32_r_en 모듈을 8 개 사용하여 구현하였다.
```
```
iii. 3_to_8_decoder
해당 모듈은 3bit의 신호를 8bit의 신호로 디코딩하는 모듈이다. 해당 모듈에서
는 case문을 활용하여 각 값에따라 알맞는 디코딩 값을 출력으로 대입시켜준다.
```
```
iv. write_operation
해당 모듈에서는 Write operation을 구현한다. 해당 모듈에서는 3_to_8_decoder
를 사용하여 저장할 위치(wAddr)를 Decoder를 통해 선별하여 데이터를 입력시
```

```
켜준다. 그리고 we(Write Enable) 신호와 and gate로 연결하여 쓰기 신호가 활성
화될 경우에만 쓰기를 실행하도록 만들어준다.
```
```
v. _8_to_1_MUX
해당 모듈은 8 개의 신호 중 하나의 신호를 rAddr를 통해 선별(MUX) 사용하여
읽어주는 방식을 사용한다. 해당 모듈은 case문을 활용하여 제작되었다.
```
```
vi. read_operation
해당 모듈은 읽기 작업을 수행한다. 해당 모듈에서 8 개의 32bit의 값을 선별하여
하나의 데이터 묶음만 읽도록 함으로써 이를 구현하였다. 여기에는
_ 8 _to_1_MUX를 활용하였다.
```
```
vii. Register_file
해당 모듈은 RF를 실질적으로 구현한 회로다. 해당 회로에서는 위에서 만든
write_operation, read_operation, register32_8을 연결하여 이를 구현하였다.
```
4. 설계 검증 및 실험 결과

A. 시뮬레이션 결과

```
해당 testbench는 _register32_r_en을 검증한다. 해당 결과를 보면 정상적으로 32 비트의
값이 저장되는 것을 알 수 있다.
```

해당 testbench는 register File에 대해 검증한다. 해당 결과를 보면 8 개의 값이 reset과
en의 값에 따라 데이터가 저장되는 모습을 확인할 수 있다.

해당 testbench는 _3_.to_8_decoder에 대해 검증한다. 해당 결과를 보면 각 위치에 따라
위치에 해당하는 비트만 1 로 활성화되는 것을 알 수 있다.


해당 testbench에서는 write_operation을 검증한다. 위의 결과를 we가 활성화 되어있을
때만 정해진 위치에 데이터가 전달되는 것을 확인할 수 있다.

해당 testbench에서는 _8_to_1_MUX를 검증한다. 해당 결과를 보면 읽는 위치에 따라 각
위치의 32 비트 값이 정상적으로 읽히는 것을 확인할 수 있다.


해당 testbench에서는 read_operation을 검증한다. 해당 결과를 보면 정상적으로 해당 위
치의 값을 불러오는 것을 확인할 수 있다.

해당 testbench에서는 Register_file을 검증한다. 해당 결과에서 볼 수 있다시피 정상적으
로 각각의 위치에 데이터를 저장하고, 각각의 위치에서 데이터를 읽어오는 것을 확인할
수 있다.

B. 합성(synthesis) 결과

```
register32_r_en
```

```
register32_
```
_ 3 _to_8_decoder

```
write operation
```
```
_8_to_1_MUX
```

```
read_operation
```
```
Register_file
```
(^)
해당 모듈의 설계를 확인하면 각각의 모듈이 정상적으로 설계되어 연결되었음을 알 수
있다.
C. FPGA board targeting 결과

5. 고찰 및 결론

```
A. 고찰
해당 과제를 진행하면서 여러가지 에로사항이 있었다. 특히 register32_8을 검증할 때 핀
의 개수가 부족하여 컴파일이 에러가 나온 상황이 발생하였다. 이를 해결하기 위해 조교
님에게 메일을 보내어 작업하는 환경을 바꾸어 이를 해결할 수 있었다. 이외에는 어렵지
않게 과제를 수행할 수 있었다.
```
```
B. 결론
해당 과제를 통해 컴퓨터에서 read의 과정은 MUX를 통해 이루어지는 것을 알 수 있다.
write 과정은 Decoder를 통해 구동되는 것을 알 수 있다. 기존의 데이터를 유지하기 위해
MUX를 활용하여 데이터를 지속적으로 넣어줌으로서 이를 구현할 수 있다.
```
6. 참고문헌
    이준환 교수님/디지털논리회로 1 /광운대학교(컴퓨터정보공학부)/


- 이준환 교수님/디지털논리회로2/광운대학교(컴퓨터정보공학부)/


